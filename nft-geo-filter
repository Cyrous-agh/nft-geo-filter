#!/usr/bin/env python3

import argparse
import logging
import os
import subprocess
import sys
import tempfile
import urllib.request
import textwrap
from pathlib import Path

# Konfiguration der Provider
SUPPORTED_PROVIDERS = {
    'ipdeny.com': {
        'v4': 'https://www.ipdeny.com/ipblocks/data/aggregated/{}-aggregated.zone',
        'v6': 'https://www.ipdeny.com/ipv6/ipaddresses/aggregated/{}-aggregated.zone'
    },
    'ipverse.net': {
        'v4': 'https://raw.githubusercontent.com/ipverse/rir-ip/master/country/{}/ipv4-aggregated.txt',
        'v6': 'https://raw.githubusercontent.com/ipverse/rir-ip/master/country/{}/ipv6-aggregated.txt'
    }
}

class GeoFilter:
    def __init__(self, args):
        self.args = args
        self.logger = self._setup_logging()
        self.policy = "drop" if args.allow else "accept"
        self.action = "accept" if args.allow else "drop"

    def _setup_logging(self):
        """Konfiguriert das Logging basierend auf der Verbosity."""
        level = logging.WARNING
        if self.args.verbose == 1:
            level = logging.INFO
        elif self.args.verbose > 1:
            level = logging.DEBUG
        
        logging.basicConfig(level=level, format='%(levelname)s: %(message)s')
        return logging.getLogger("GeoFilter")

    def fetch_ips(self, family, country):
        """Lädt IP-Listen herunter und bereinigt sie."""
        url_template = SUPPORTED_PROVIDERS[self.args.provider][family]
        url = url_template.format(country.lower())
        
        try:
            self.logger.info(f"Lade {family} Daten für {country}...")
            with urllib.request.urlopen(url, timeout=20) as response:
                content = response.read().decode('utf-8')
                # Filtert Kommentare und leere Zeilen
                ips = [line.strip() for line in content.splitlines() 
                       if line.strip() and not line.startswith('#')]
                return ips
        except Exception as e:
            self.logger.error(f"Fehler beim Download ({country}/{family}): {e}")
            return []

    def build_nft_config(self):
        """Erstellt den String für die nftables Konfigurationsdatei."""
        lines = []
        # Tabellen-Definition
        lines.append(f"table {self.args.table_family} {self.args.table_name} {{")
        
        # IP Sets erstellen
        families = []
        if not self.args.no_ipv4: families.append(('v4', 'ipv4_addr', 'filter-v4'))
        if not self.args.no_ipv6: families.append(('v6', 'ipv6_addr', 'filter-v6'))

        for key, nft_type, set_name in families:
            all_ips = []
            for c in self.args.country:
                all_ips.extend(self.fetch_ips(key, c))
            
            lines.append(f"    set {set_name} {{")
            lines.append(f"        type {nft_type}")
            lines.append("        flags interval")
            lines.append("        auto-merge")
            if all_ips:
                lines.append("        elements = { " + ", ".join(all_ips) + " }")
            lines.append("    }")

        # Chain Definition
        hook = "prerouting"
        if self.args.table_family == "netdev":
            if not self.args.interface:
                self.logger.error("Netdev benötigt ein Interface (-i)!")
                sys.exit(1)
            hook = f"ingress device {self.args.interface}"

        lines.append(f"    chain filter-chain {{")
        lines.append(f"        type filter hook {hook} priority -190; policy {self.policy};")

        # Connection Tracking (Established/Related)
        if self.args.allow_established:
            lines.append("        ct state established,related accept")

        # Exceptions (Manuelle Erlaubnisse)
        if self.args.exceptions:
            exc_list = [x.strip() for x in self.args.exceptions.split(',')]
            v4_exc = [x for x in exc_list if ":" not in x]
            v6_exc = [x for x in exc_list if ":" in x]
            if v4_exc: lines.append(f"        ip saddr {{ {', '.join(v4_exc)} }} accept")
            if v6_exc: lines.append(f"        ip6 saddr {{ {', '.join(v6_exc)} }} accept")

        # Hauptregeln für die Sets
        log_str = ""
        if (self.args.log_accept and self.args.allow) or (self.args.log_drop and not self.args.allow):
            prefix = self.args.log_accept_prefix if self.args.allow else self.args.log_drop_prefix
            level = self.args.log_accept_level if self.args.allow else self.args.log_drop_level
            log_str = f"log prefix \"{prefix or ''}\" level {level or 'warn'} "

        if not self.args.no_ipv4:
            lines.append(f"        ip saddr @filter-v4 {self.args.counter} {log_str}{self.action}")
        if not self.args.no_ipv6:
            lines.append(f"        ip6 saddr @filter-v6 {self.args.counter} {log_str}{self.action}")

        lines.append("    }")
        lines.append("}")
        return "\n".join(lines)

    def run(self):
        """Generiert die Config und wendet sie an."""
        if os.geteuid() != 0:
            self.logger.error("Dieses Skript muss als root ausgeführt werden!")
            sys.exit(1)

        config_data = self.build_nft_config()
        
        with tempfile.NamedTemporaryFile(mode='w', suffix='.nft', delete=False) as tmp:
            tmp.write(config_data)
            tmp_path = tmp.name

        try:
            self.logger.info(f"Wende Konfiguration über {tmp_path} an...")
            # Atomares Laden der Konfiguration
            result = subprocess.run([self.args.nft_location, "-f", tmp_path], 
                                    capture_output=True, text=True, check=True)
            self.logger.info("Erfolgreich aktualisiert.")
        except subprocess.CalledProcessError as e:
            self.logger.error(f"nftables Fehler:\n{e.stderr}")
            # Optional: Hier könnte man die Temp-Datei behalten zur Fehlersuche
        finally:
            if os.path.exists(tmp_path):
                os.remove(tmp_path)

def main():
    parser = argparse.ArgumentParser(description='Geo-IP Filter für nftables (Optimiert)')
    
    parser.add_argument("-v", "--verbose", action="count", default=0)
    parser.add_argument("-l", "--nft-location", default="/usr/sbin/nft")
    parser.add_argument("-a", "--allow", action="store_true", help="Whitelist Modus (Default: Blacklist)")
    parser.add_argument("--allow-established", action="store_true", help="Erlaubt Antwortpakete")
    parser.add_argument("-c", "--counter", action="store_const", const="counter", default="")
    parser.add_argument("--provider", default="ipverse.net", choices=SUPPORTED_PROVIDERS.keys())
    parser.add_argument("-f", "--table-family", choices=["ip","ip6","inet","netdev"], default="inet")
    parser.add_argument("-n", "--table-name", default="geo-filter")
    parser.add_argument("-i", "--interface", help="Interface für netdev")
    parser.add_argument("--no-ipv4", action="store_true")
    parser.add_argument("--no-ipv6", action="store_true")
    parser.add_argument("-e", "--exceptions", metavar="IPS", help="Kommagetrennte Liste von IPs/Subnetzen")
    
    # Logging
    parser.add_argument("--log-accept", action="store_true")
    parser.add_argument("--log-accept-prefix")
    parser.add_argument("--log-accept-level", default="warn")
    parser.add_argument("--log-drop", action="store_true")
    parser.add_argument("--log-drop-prefix")
    parser.add_argument("--log-drop-level", default="warn")

    parser.add_argument("country", nargs='+', help="ISO-Ländercodes (z.B. de us cn)")

    args = parser.parse_args()
    
    filter_tool = GeoFilter(args)
    filter_tool.run()

if __name__ == '__main__':
    main()
